<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head>
    <title>Group Chat Orchestration</title>
    <style type="text/css" media="screen">
		@import url( ../shared/style.css );
	</style>
	<script src="../shared/scormfunctions.js" type="text/javascript"></script>
	<script src="../shared/contentfunctions.js" type="text/javascript"></script>
</head>
<body>
<h1>Group Chat Orchestration</h1>

<h2>Beyond One-to-One Conversations</h2>
<p>
    While the two-agent pattern (UserProxy + Assistant) handles many tasks, complex workflows often require specialized roles.
    For example, software development might need a Product Manager, a Coder, a Reviewer, and a Tester.
    AutoGen supports this through the <strong>Group Chat</strong> pattern.
</p>

<h2>The GroupChat Class</h2>
<p>
    The <code>GroupChat</code> class is a container that holds a list of agents and manages the state of their conversation.
    It doesn't "run" the chat itself; it defines the participants and the rules.
</p>
<p>
    <strong>Key Parameters:</strong>
</p>
<ul>
    <li><strong>agents:</strong> A list of participating agents.</li>
    <li><strong>messages:</strong> The history of the conversation (visible to all agents).</li>
    <li><strong>max_round:</strong> The maximum number of turns allowed in the chat.</li>
    <li><strong>speaker_selection_method:</strong> The strategy used to decide who speaks next.</li>
</ul>

<h2>The GroupChatManager</h2>
<p>
    The <code>GroupChatManager</code> is a special agent that acts as the administrator. It takes the <code>GroupChat</code> object as input.
    When you start a chat, you initiate it with the Manager.
</p>
<p>
    The Manager's job is to:
</p>
<ol>
    <li>Listen to the last message added to the group.</li>
    <li>Consult the <code>speaker_selection_method</code> (or ask an LLM) to select the next speaker.</li>
    <li>Broadcast the selected speaker's message to all other agents in the group.</li>
</ol>

<h2>Speaker Selection Methods</h2>
<p>
    The efficiency of a group chat depends heavily on selecting the right agent at the right time. AutoGen supports several strategies:
</p>

<h3>1. Auto (Default)</h3>
<p>
    The Manager uses an LLM to decide who should speak next based on the conversation history and the agents' descriptions.
    It is crucial to provide a clear <code>description</code> for each agent in the group so the LLM understands their roles.
</p>

<h3>2. Round Robin</h3>
<p>
    Agents speak in the order they are listed in the <code>agents</code> list. Simple, but rigid.
</p>

<h3>3. Random</h3>
<p>
    Selects the next speaker randomly. Useful for brainstorming or stress testing.
</p>

<h3>4. Manual</h3>
<p>
    Delegates the decision to a human user.
</p>

<h2>Customizing the Graph</h2>
<p>
    For advanced orchestration, you can define a <strong>Transition Graph</strong> (Finite State Machine).
    You can restrict which agents can follow which. For example, you might enforce that the "Coder" can only be followed by the "Reviewer", preventing the "Manager" from jumping in prematurely.
    This is done by passing a dictionary of allowed transitions to the <code>GroupChat</code>.
</p>

<h2>Summary</h2>
<p>
    Group Chats allow for "Society of Agents" architectures. The key to success is clear role definitions (System Messages) and accurate Agent Descriptions, enabling the Manager to orchestrate effectively.
</p>

<script type="text/javascript">
</script>
</body>
</html>