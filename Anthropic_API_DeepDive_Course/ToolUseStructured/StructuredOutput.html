<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head>
    <title>Structured Output: Enforcing Data Integrity</title>
    <style type="text/css" media="screen">
		@import url( ../shared/style.css );
	</style>
	<script src="../shared/scormfunctions.js" type="text/javascript"></script>
	<script src="../shared/contentfunctions.js" type="text/javascript"></script>
</head>
<body>
<h1>Structured Output: Enforcing Data Integrity</h1>

<div class="content-section">

<h2>Concept Overview</h2>
<p>One of the biggest challenges in working with LLMs is their tendency to be verbose. Ask a model for a list of names, and it might reply with "Here is the list you asked for: 1. Alice, 2. Bob. Let me know if you need anything else!" Parsing this text programmatically is fragile and error-prone.</p>
<p><strong>Structured Output</strong> solves this by forcing the model to generate valid JSON that strictly adheres to a predefined schema. This transforms the LLM from a chatty assistant into a reliable data processing engine.</p>

<h2>Detailed Explanation: The "Tool Use" Hack</h2>
<p>While some models offer a dedicated "JSON mode," the most robust way to get structured output from Claude is to define a tool that represents your desired data structure and then <em>force</em> the model to use it.</p>
<p>For example, if you want to extract customer details, you define a tool named `record_customer_details`. You don't actually need to implement this function in your code. You simply use the model's generated arguments as your final output.</p>

<h3>Designing Effective Schemas</h3>
<p>The quality of the output depends heavily on the specificity of your JSON Schema. A loose schema leads to hallucinations; a tight schema ensures precision.</p>

<ul>
    <li><strong>Descriptions are Prompts:</strong> Every field in your schema should have a `description`. For a field named `sentiment`, don't just say "The sentiment." Say "The emotional tone of the review, classified as positive, negative, or neutral."</li>
    <li><strong>Enums for Classification:</strong> Use `enum` to restrict string fields to a specific set of allowed values. This guarantees that your downstream logic (e.g., `if sentiment == 'positive'`) will always work.</li>
    <li><strong>Validation:</strong> Use `pattern` (regex) for fields like phone numbers or emails to enforce format constraints at the generation level.</li>
</ul>

<blockquote>
// Robust Schema Example
{
  "name": "extract_order",
  "description": "Extract order details from a customer email.",
  "input_schema": {
    "type": "object",
    "properties": {
      "product_id": {
        "type": "string",
        "pattern": "^PROD-\\d{4}$",
        "description": "The product ID, formatted as PROD-XXXX."
      },
      "quantity": {
        "type": "integer",
        "minimum": 1,
        "description": "The number of items ordered."
      },
      "shipping_method": {
        "type": "string",
        "enum": ["standard", "express", "overnight"],
        "description": "The requested shipping speed."
      }
    },
    "required": ["product_id", "quantity"]
  }
}
</blockquote>

<h2>Technical Breakdown: Handling Complexity</h2>
<p>Structured output isn't limited to flat objects. You can define deeply nested structures, arrays of objects, and recursive types. This allows you to model complex entities like an entire invoice with line items, a medical record with history, or a complete code syntax tree.</p>

<h3>The `required` Keyword</h3>
<p>The `required` array in your JSON Schema is your strongest tool for preventing data loss. If a field is in `required`, the model will make a best-effort attempt to populate it, even if it has to infer the value from context. If a field is optional, the model may omit it if the information isn't explicitly present.</p>

<h2>Real-World Examples</h2>
<ul>
    <li><strong>Resume Parsing:</strong> Convert a PDF resume (text) into a structured JSON profile with separate fields for education, experience, and skills.</li>
    <li><strong>Log Analysis:</strong> Turn messy server logs into structured events with timestamps, error codes, and severity levels.</li>
    <li><strong>Calendar Scheduling:</strong> Extract meeting intent, attendees, and time ranges from an email thread into a calendar event object.</li>
</ul>

<h2>Key Takeaways</h2>
<ul>
    <li>Use a "dummy" tool definition to force structured output.</li>
    <li>Treat schema descriptions as mini-prompts for each field.</li>
    <li>Leverage <code>enum</code> and <code>pattern</code> to constrain the model's creativity.</li>
    <li>Always validate the output against your schema on the client side, as models can still occasionally make mistakes.</li>
</ul>

</div>

<script type="text/javascript">
// SCORM initialization if needed
</script>
</body>
</html>